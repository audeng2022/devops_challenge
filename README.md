# DevOps Challenge
Austin Deng

The goal of this DevOps technical challenge involves using Terraform to create AWS infrastructure and a Github Actions workflow to deploy a web application on an EC2 instance.
________________________________

## **Overview**

This repository includes a containerized flask application, a set of Terraform files that create basic infrastructure in AWS, and a Github Actions workflow that deploys that containerized flask application on the infrastructure created from the Terraform files. The AWS infrastructure is created through Terraform files consisting of an EC2 instance which is responsible for running Docker and hosting the application which runs the container on boot, as well as the associated networking and IAM resources including an Application Load Balancer that receives HTTP traffic on port 80 and routes requests to the EC2 instance. On push to the repository, the Github Actions workflow triggers a workflow that builds the Docker image, pushes it to Amazon ECR, and deploys the new version to the EC2 instance through AWS SSM. The resulting deployment can be verified by visiting the url in a browser to find the /info route: http://<alb-dns>.com/info where <alb-dns> is the name of the load balancer dns.

There are 3 files and 2 folders in the root of this repository
- The /infra/ folder has 3 Terraform files including main.tf and a template file; you will want to download this folder onto your computer for part 1 to generate the finfrastructure
- app.py, dockerfile, and requirements.txt work together to package the flask app into a Docker image. The app.py is a Flask service that exposes /info. The Docker image is built from the python base image and runs app.py, exposing port 5000 in the container. Finally the dependencies are installed from requirements.txt
- /.github/workflows/deploy.yml is the Github Actions workflow. Once you have generated the AWS infrastructure you will activate this workflow to deploy the app to the EC2 instance

## **Prerequisites**
There are some prerequisites that you will need to have ready before starting on this challenge:
- An AWS account (at least Free tier)
- An IAM user role on the AWS account with admin level access (or at least access to create & manage the resources in the Terraform script)
- A Github account with permissions to configure repository secrets and run Actions
- Terraform installed locally, and it is also recommended to have AWS CLI, Docker, Git installed as well
  
You can fork this Github repository onto your account to use the files and Github Actions workflow you will use in part 2.

## **1) How to deploy infrastructure**
**1.1 Retrieve credentials from AWS**

You will need to record 3 variables from AWS, you will use them in subsequent steps.
Through the AWS console, navigate the IAM > Select the IAM user you will be using > Security Credentials > Create Access Key
- **AWS_ACCESS_KEY_ID**: This is the Access Key on AWS you will use to authenticate credentials
- **AWS_SECRET_ACCESS_KEY**: This is the Secret Access Key that is provided only once upon creation
- **AWS_REGION**: This is the AWS region that you want to use to deploy your infrastructure and application; in this example we will be using us-east-1

**1.2 Store credentials as local environment variables**

You will need to open Command Line Interface on your local computer.
In this example I will be using Windows Powershell, but syntax may vary depending the CLI you use.
First ensure the the Terraform files are downloaded under a folder, then change directory to that folder:

    cd "/path/to/terraform_infra/files"
Set the environmental variables based on the credentials you collected in the previous step. Terraform's AWS provider will automatically check for the listed environmental variables for credentials

    $env:AWS_ACCESS_KEY_ID="AXXXXXXXXXXXXXX"
    $env:AWS_SECRET_ACCESS_KEY="XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
    $env:AWS_REGION="us-east-1"

**1.3 Apply Terraform and deploy infrastructure**

Now you're ready to run Terraform. You can run the following commands to deploy the infrastructure, checking at each stage to confirm the deployment looks correct. There should be 12 resources that are generated by the files.

    terraform init
    terraform plan
    terraform apply
Once the Apply is completed, you should receive 3 outputs:

    alb_dns_name = "devops-challenge-XXXXXXXXXX.us-east-1.elb.amazonaws.com"
    ec2_name_tag = "devops-challenge-ec2"
    ecr_repository_name = "devops-challenge-repo"

Record all 3 outputs down, you will need them in the next step.
You have completed the infrastructure deployment step of the challenge. The next step is to deploy the application using a CI/CD pipeline.

## **2) How to trigger deployment**
**2.1 Prepare environment in Github**

In this step, now that you have the infrastructure in place, you will now use Github Actions to build the Docker image, push it to Amazon ECR, and deploy to the EC2 instance.

The first step you need to do is go to your Github repository

Settings > Environments > New Environment

Name this environment: "deployment"

**Environment Secrets**
- **AWS_ACCESS_KEY_ID**: The same Access Key you collected and used earlier
- **AWS_SECRET_ACCESS_KEY**: The same Secret Access Key you collected and used earlier
- **AWS_REGION**: The same region you used earlier
- **ECR_REPOSITORY: ecr_repository_name** output after applying Terraform, the default is: **"devops-challenge-repo"**

**Environment Variables**
- **EC2_NAME_TAG: ec2_name_tag** output after applying Terraform, the default is: **"devops-challenge-ec2"**

**2.2 Start the Github Actions CI/CD Pipeline**

Push a change to any of the files in the main branch. This can just be adding a comment which will trigger the Github Actions Workflow.

Go to Actions > <Username> is deploying to EC2 > deploy.yml will run
Check to see if it is successful. If you see a green checkmark, all that's left is to test the application.

**2.3 Test the app deployment**

You can test your deployment 2 different ways. Option 1 is to use a curl command to reach the endpoint:

    curl devops-challenge-XXXXXXXXXX.us-east-1.elb.amazonaws.com/info
Option 2 is to enter the ALB DNS name in a browser:

http://devops-challenge-XXXXXXXXXX.us-east-1.elb.amazonaws.com/info

If you receive the EC2 instance id, availability zone, and timestamp in a JSON, then you have successfully deployed the application on EC2. 
  
## **Assumptions Made**
There are are a number of assumptions that have been made in this project. Some are touched upon in the prerequisites section.

1) The Terraform region and Github Actions AWS_REGION are identical, so for what region which is specified in part 1 (likely us-east-1 as default) must be the region that is referenced by AWS_REGION, otherwise GA will attempt to push to an ECR repo in a region different from the one EC2 resides in.

2) The IAM user whose AWS credentials are used has Admin level access or at least the appropriate permissions in order to create the resources in the Terraform files as well as push the image to ECR and deploy the app on EC2.

3) The EC2 instance can reach the internet in order to pull images and communicate with SSM. That measn the instance must reach the SSM endpoints and ECR endpoints.

4) The EC2 instance is active once the Github Actions workflow is triggered. In case the EC2 instance is not active from a potential delay after deploying the Terraform scripts, the container will not be able to be deployed.

5) The version of Terraform installed matches the required version in the script (>=1.5.0)
   
   

## **Improvements in Production**

There are a number of improvements that can be made in a production environment, primarily in relation to security and resilience of the deployment.

1. Use HTTPS instead of HTTP to deliver the app. This encrypts traffic so that credentials and data aren't readable if intercepted. For instance, an ACM certificate can be added and ALB can be changed to listen on 443 instead.

2. Use WAF (Web Application Firewall), which helps filter attacks and help reduce risk. WAF can be added as an attachment to ALB.

3. Add metrics and alarms to help track when production is down and it is detected.

4. Instead of storing keys in Github secrets use Github OIDC for better security and more temporary credentials

5. Use autoscaling to scale instances based on workload which will help optimize, saving money while giving high availability which also works well with containerized apps.

